## 1. 多语言数据的数据库模式设计

选择正确的数据库模式是数据国际化的基础，它会影响可伸缩性、性能和可维护性。本节将探讨三种常见的实现方法。

### 1.1 基于列的方法

* ​**描述**​：这是最简单的方法。对于每个需要本地化的属性，为每种支持的语言添加一个单独的列（例如，`product_name_en`、`product_name_fr`、`product_description_en`、`product_description_fr`）。
* ​**Spring Data JPA映射**​：每个特定语言的列直接映射到JPA实体中的一个字段（例如，`private String nameEn; private String nameFr;`）。
* ​**优点**​：
  * 实现和理解简单。
  * 检索所有翻译或特定翻译的查询性能快，因为不需要`JOIN`操作。
  * 每条记录的数据量小。
* ​**缺点**​：
  * 不可伸缩：列的数量随着本地化属性的数量乘以语言的数量呈线性增长，可能导致“大量”的列。
  * 添加新语言需要更改数据库模式（添加新列），这可能会带来中断。
  * 如果需要回退，查询特定语言可能涉及复杂的`COALESCE`函数，并且获取实体会加载所有翻译，即使它们未被使用。
* ​**用例**​：适用于语言数量有限且稳定，并且模式更改不频繁的小型项目。

研究表明，基于列的方法因其简单性和直接映射而备受推崇。然而，研究也强调了其在可伸缩性和模式演进（添加新语言）方面的显著缺点。这意味着，虽然这种方法最初看起来很有吸引力，但对于不断增长的应用程序来说，它会带来技术债务。这种“简单性”是以牺牲未来的敏捷性和增加模式迁移的维护开销为代价的。因此，对于任何具有增长潜力或不断变化的语言需求的应用程序，尽管其最初易于实现，仍应仔细重新考虑这种方法。

### 1.2 基于JSON/HSTORE的方法

* ​**描述**​：使用单个列（通常命名为`translations`或类似名称）来存储同一表中其他列的所有翻译，利用JSON（或PostgreSQL中的HSTORE）数据类型。该列的值是一个JSON对象，其中键是语言代码（例如“en”、“fr”），值是翻译后的字符串或嵌套对象。
* ​**Spring Data JPA映射**​：
  * ​**`AttributeConverter`**​：对于JPA 2.1+，`AttributeConverter`可以弥合自定义Java类型（例如`Map<String, String>`）与`VARCHAR`或`JSONB`数据库列之间的差距。这涉及到在持久化前将Java对象转换为JSON字符串，并在检索时反序列化回来。
  * ​**Hypersistence Utilities**​：像Hypersistence Utilities这样的库提供了预构建的自定义类型（例如`JsonType`），用于将JSON轻松映射到数据库系统，从而抽象了转换逻辑。这通常因其便利性而受到青睐。
  * ​**Hibernate 6 `SqlTypes.JSON`**​：随着Hibernate 6的发布，通过`SqlTypes.JSON`提供了对JSON类型的原生支持，从而消除了对外部库进行基本JSON映射的需求。
  * JSON字段的查询可以使用原生查询或通过在Hibernate方言中注册自定义SQL函数来完成。
* ​**优点**​：
  * 可伸缩且灵活：无需更改模式即可轻松添加新语言。
  * 减少列的数量，使主表更整洁。
  * 可以减少数据大小，并可能导致简单检索的查询时间更快，特别是当经常需要整个JSON对象时。
* ​**缺点**​：
  * 管理复杂性：随着语言和翻译列数量的增加，JSON对象可能变得难以管理和维护，可能导致错误和不一致。
  * 查询性能：当从大型JSON对象中提取特定数据时，查询可能变得缓慢和低效，特别是当需要对嵌套JSON字段进行复杂过滤或索引时。
  * 并发问题：多个用户对同一JSON对象进行并发更新可能导致数据不一致和冲突，需要额外的锁定机制。
  * 数据库特定函数：查询和索引通常依赖于数据库特定的JSON函数（例如PostgreSQL JSONB操作符），这可能会降低可移植性。
* ​**用例**​：适用于需要灵活管理翻译的应用程序，特别是当本地化内容的模式不严格固定或本地化属性数量较多时。

JSON方法在无需模式更改的情况下提供了显著的灵活性，允许添加新语言。然而，研究也指出其潜在的性能下降，尤其是在复杂查询中，并且可能需要数据库特定的函数和索引（如PostgreSQL的GIN索引）。这意味着，尽管模式灵活性是一个主要优势，但开发人员必须充分认识到性能方面的权衡。这种方法将复杂性从模式管理转移到查询优化，并且可能需要更深入的数据库特定知识。它还带来了对嵌套JSON字段进行索引的挑战，这可能不如传统列索引效率高，因此对于对本地化数据进行大量分析查询的应用程序来说，这种方法可能不太适用。

### 1.3 独立翻译表方法

* ​**描述**​：创建一个专门的表（例如`product_translations`）来存储所有本地化内容，并通过外键与主实体表关联。翻译表中的每行通常包含实体ID、区域设置代码和翻译后的字段（例如`product_id`、`locale`、`name`、`description`）。
* ​**Spring Data JPA映射**​：这种方法通常使用`@OneToMany`和`@ManyToOne`注解来建模主实体及其翻译之间的关系。主实体（例如`Product`）将包含一个`ProductTranslation`实体集合。
  * 在主实体上使用`@OneToMany(mappedBy = "product", cascade = CascadeType.ALL)`注解。
  * 在翻译实体上使用`@ManyToOne`和`@JoinColumn`注解，以链接回主实体。
  * 对于`@OneToMany`关联，设置`FetchType.LAZY`至关重要，以避免在不需要时加载翻译而导致的性能问题。
* ​**优点**​：
  * 高度可伸缩且灵活：通过简单地在翻译表中插入新行即可添加新语言，无需更改主数据库模式。
  * 无重复内容：每个翻译都存储在唯一行中，确保数据完整性。
  * 优化查询：可以通过在翻译表的外键和区域设置列上创建索引来优化查询，从而提高特定语言查找的性能。
  * 职责分离清晰：本地化数据与核心实体数据逻辑分离。
* ​**缺点**​：
  * 初始实现更复杂：需要定义额外的实体并管理关系。
  * `JOIN`操作：检索本地化数据需要主表和翻译表之间的`JOIN`操作，这可能会引入性能开销，特别是对于大型数据集或涉及多个本地化字段的复杂查询。
  * 增加存储空间：需要额外的存储空间用于独立的翻译表。
* ​**用例**​：最适合任何规模的应用程序，特别是具有大量本地化内容、频繁添加语言以及对数据完整性和结构化查询有强烈需求的大型系统。

独立的翻译表方法在添加新语言和维护数据完整性方面最为健壮和可伸缩。然而，其代价是由于必要的`JOIN`操作而增加的查询复杂性。这意味着，虽然这种方法避免了模式演进的痛苦和数据重复，但性能瓶颈转移到了查询层。开发人员必须仔细设计查询，并确保在翻译表中的外键和区域设置列上进行适当的索引。这表明，对于高性能、读密集型应用程序，缓存策略（稍后讨论）变得更加关键，以减轻重复连接的开销。

### 1.4 关键表格：多语言数据数据库模式设计比较

下表提供了开发人员快速了解各种权衡的参考。

| 特性/方法                | 基于列的方法                                                 | 基于JSON/HSTORE的方法                                              | 独立翻译表方法                               |
| -------------------------- | -------------------------------------------------------------- | -------------------------------------------------------------------- | ---------------------------------------------- |
| **描述**                | 为每种语言设置单独的列（例如，`name_en`，`name_fr`） | 单个JSON/HSTORE列存储所有翻译                                      | 专用翻译表，通过外键关联                     |
| **Spring Data JPA映射** | 直接字段映射（`String nameEn`）                          | `AttributeConverter`，Hypersistence Utils，`SqlTypes.JSON` | `@OneToMany`/`@ManyToOne`关系        |
| **可伸缩性（语言）**    | 差（需要模式更改）                                           | 优秀（无需模式更改）                                               | 优秀（无需模式更改）                         |
| **查询性能**            | 很好（无连接）                                               | 简单检索良好，复杂查询/索引差                                      | 中等（需要连接）                             |
| **数据完整性/一致性**   | 高                                                           | 中等（手动验证，并发问题）                                         | 高                                           |
| **实现复杂性**          | 低                                                           | 中等（自定义类型/函数）                                            | 高（多个实体，关系）                         |
| **存储开销**            | 低                                                           | 低（紧凑JSON）                                                     | 高（更多行）                                 |
| **模式演进**            | 困难（更改）                                                 | 容易（无更改）                                                     | 容易（新行）                                 |
| **最佳用例**            | 小型项目，少量语言，稳定模式                                 | 灵活内容，大量属性/语言，较不复杂查询                              | 大型项目，大量语言，高数据完整性，结构化查询 |

研究材料清晰地分解了每种数据库模式设计的优缺点。将这些信息整合到比较表中，为读者提供了巨大的价值。表格能够快速、并排地进行比较，使开发人员能够一目了然地掌握核心差异和权衡。它将复杂信息提炼成易于理解的格式，有助于根据其特定项目需求（例如，“如果我需要语言的高度可伸缩性，我应该避免基于列的方法”）快速做出决策。这种可视化总结加强了对每种方法更深层次的理解。
