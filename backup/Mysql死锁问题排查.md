MySQL 死锁是并发编程中常见但棘手的问题。当两个或多个事务在竞争资源（锁）时，每个事务都持有另一个事务需要的锁，从而导致它们都无法继续执行时，就会发生死锁。

MySQL 的 **InnoDB 存储引擎**具有强大的​**死锁检测机制**​，它能自动发现死锁并选择一个事务作为\*\*牺牲者（Victim）\*\*将其回滚（Rollback），从而让另一个事务继续执行。

排查 MySQL 死锁的流程主要围绕获取和分析死锁日志展开。

---

### 🔍 核心排查步骤

排查死锁最直接、最有效的方法是查看 MySQL 的 ​**InnoDB 状态日志**​。

#### 步骤 1: 获取死锁日志

使用以下命令查看最近一次死锁的详细信息：

**SQL**

```
SHOW ENGINE INNODB STATUS;
```

**分析要点：**

* 在巨大的输出结果中，你需要找到名为 `LATEST DETECTED DEADLOCK` 的部分。
* 这个部分包含了死锁发生的时间、涉及的事务（Transaction）ID、持有的锁（Holds lock）、等待的锁（Waits for lock）以及详细的 SQL 语句。

#### 步骤 2: 开启错误日志（如果需要）

如果需要记录所有历史死锁信息（不仅仅是最近一次），需要确保 MySQL 错误日志记录了 InnoDB 状态信息：

* **检查配置：** 确保 `innodb_print_all_deadlocks` 参数被设置为 `ON`。
  **SQL**
  
  ```
  SHOW VARIABLES LIKE 'innodb_print_all_deadlocks';
  ```
* **启用：** 如果是 `OFF`，可以动态开启：
  **SQL**
  
  ```
  SET GLOBAL innodb_print_all_deadlocks = ON;
  ```
* **查看：** 开启后，所有死锁信息都会写入 MySQL 的错误日志文件（通常位于 `/var/log/mysql/error.log` 或数据目录）。

#### 步骤 3: 分析死锁日志内容

`LATEST DETECTED DEADLOCK` 部分的日志结构通常非常清晰，你需要找出以下关键信息：

| **日志段**                             | **描述**                                   | **如何分析**                                                   |
| ---------------------------------------------- | -------------------------------------------------- | ---------------------------------------------------------------------- |
| **`*** (1) TRANSACTION:`**              | 第一个事务的信息（被选为牺牲者回滚的概率较高）。 | 记下**Transaction ID**和事务​**等待的锁**​。                     |
| **`*** (1) WAITING FOR THIS LOCK(S):`** | 事务 1 当前正在等待的资源（锁）。                | 确定资源类型（行锁、间隙锁、表锁）和资源 ID（表的哪个索引或行）。    |
| **`*** (2) TRANSACTION:`**              | 第二个事务的信息。                               | 记下**Transaction ID**和事务​**持有的锁**​。                     |
| **`*** (2) HOLDS THIS LOCK(S):`**       | 事务 2 当前持有的资源（锁）。                    | 确定事务 2 持有的是哪个锁，而这个锁恰好是事务 1 想要的。             |
| **`*** (2) WAITING FOR THIS LOCK(S):`** | 事务 2 当前正在等待的资源。                      | 这个资源应该就是事务 1 当前持有的锁。​**确认是否存在循环等待**​。 |
| **`*** WE ROLL BACK TRANSACTION (1)`**  | InnoDB 死锁检测器的决定。                        | 表明事务 (1) 被选中并回滚。                                          |

**分析核心：** 死锁的本质是 ​**资源循环依赖**​。日志分析的目标是找出：

\$\$\\text{事务 A} \\xrightarrow{\\text{等待}} \\text{事务 B 持有} \\xrightarrow{\\text{等待}} \\text{事务 A 持有}\$\$

---

### 🎯 常见的死锁类型及优化

死锁通常发生在\*\*行锁（Row Lock）\*\*或 \*\*间隙锁（Gap Lock）\*\*上，尤其是在事务隔离级别为 **REPEATABLE READ** 时。

| **常见死锁场景**     | **优化建议**                                                                                                             |
| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| **UPDATE 顺序不一致**     | ​**强制所有涉及相同资源的事务，以相同的顺序访问和锁定资源。**​（例如：总是先锁 ID 小的，再锁 ID 大的）。                    |
| **索引缺失或不当**        | 在`WHERE`条件中使用的字段上建立​**索引**​。如果没有索引，InnoDB 可能升级为**表锁**或锁定更多不必要的行，增加死锁几率。 |
| **间隙锁冲突**            | 事务在没有行数据的地方加了锁（间隙锁）。如果业务允许，可考虑将事务隔离级别降低到​**READ COMMITTED**​（这会禁用间隙锁）。    |
| **SELECT ... FOR UPDATE** | 确保`SELECT ... FOR UPDATE`语句中的`WHERE`条件能命中索引。否则，会锁定整个表或大片范围。                               |
| **长事务**                | 尽量缩短事务的持续时间。事务持续时间越长，它持有锁的时间就越长，与其他事务发生冲突的几率就越大。                               |


